---
sidebar_position: 17
---

# 生命周期

Rust 的生命周期（lifetime）是编译器通过借用检查器确保引用在作用域内始终有效的一种机制。生命周期在 Rust 中的核心目标是确保**内存安全**，尤其是避免**悬空引用**（dangling references）和**数据竞态**。

以下是 Rust 生命周期的主要概念和使用方式，包括生命周期的基本定义、注解规则、常见的生命周期标注，以及高级使用场景。

### 1. 生命周期的基础概念

Rust 编译器会为每个引用分配一个生命周期，生命周期其实是一个作用范围，告诉编译器这个引用在程序的哪一部分是有效的。通过生命周期，Rust 可以在编译时检查引用是否有效，以确保引用的安全性。

### 2. 生命周期标注的语法

生命周期标注通常用 `'a`、`'b` 等名称来表示，并附加在引用类型上。标注不是改变生命周期的长度，而是明确地告诉编译器各个引用的生命周期关系。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

在这个 `longest` 函数中，`'a` 是一个生命周期参数，它告诉编译器，`x` 和 `y` 引用的生命周期必须一致，并且返回值的生命周期与输入的生命周期之一保持一致。这意味着返回的引用在调用者看来是安全的。

### 3. 生命周期注解规则

生命周期标注通常在以下情况下需要显式添加：

- 函数或方法接收多个引用参数。
- 函数返回一个引用。
- 多个引用参数有生命周期关系，编译器无法推断出唯一的生命周期。

#### 生命周期的隐式省略规则

Rust 通过三个隐式省略规则，让很多情况下无需显式添加生命周期标注：

1. 每个**输入引用**都获得一个独立的生命周期。
2. 如果只有一个**输入引用**，那么返回的引用默认与该输入生命周期一致。
3. 如果存在**多个输入引用**，但其中之一是 `self`，那么返回的引用生命周期与 `self` 的生命周期一致。

例如：

```rust
fn first_word(s: &str) -> &str {
    // 根据省略规则自动推断
}
```

在 `first_word` 中，没有显式声明生命周期，因为编译器会根据省略规则为输入参数和返回值添加相同的生命周期。

### 4. 常见生命周期示例

#### 引用的生命周期相同

函数接受两个引用参数，并返回一个生命周期相同的引用：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

这里，`'a` 指定了 `x`、`y` 和返回值的生命周期，表示它们的生命周期必须一致。调用者需要确保传入的引用在同一个生命周期内。

#### 引用的不同生命周期

如果需要返回一个引用，且引用的生命周期可能不同，则可以灵活指定不同的生命周期：

```rust
fn choose<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    x
}
```

在此示例中，`'a` 和 `'b` 是两个不同的生命周期，但函数规定返回的是 `'a` 生命周期的引用，即与 `x` 的生命周期一致。此时，`x` 和返回值的生命周期相同，但 `y` 的生命周期可以不同。

### 5. 生命周期与结构体

结构体中的引用类型字段必须带有生命周期标注，以确保结构体实例在有效的生命周期内。

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("{}", announcement);
        self.part
    }
}
```

在这里，`ImportantExcerpt` 结构体有一个引用字段 `part`，所以需要给结构体加上生命周期 `'a`。`announce_and_return_part` 方法返回了一个引用，生命周期为 `self` 的生命周期，确保结构体的引用始终有效。

### 6. 生命周期省略示例

有时省略规则可以让我们不用显式添加生命周期标注。以下是一些自动推断的情况：

```rust
fn first_word(s: &str) -> &str {
    // 根据省略规则，这里省略了生命周期标注
}
```

以上函数的完整形式是 `fn first_word<'a>(s: &'a str) -> &'a str`，但编译器会自动应用第一条和第二条省略规则。

#### 使用省略规则的场景

1. **一个参数，返回一个引用**：返回值与输入参数的生命周期一致。
2. **多个参数，返回 `self`**：在结构体方法中，`self` 的引用生命周期与返回值相同。

### 7. 生命周期约束

Rust 允许我们将生命周期标注与 `trait` 约束结合：

```rust
fn longest_with_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
where
    T: Display,
{
    println!("{}", ann);
    if x.len() > y.len() { x } else { y }
}
```

在这里，`T` 是泛型类型，且必须实现 `Display` trait。`longest_with_announcement` 函数返回值的生命周期与输入参数之一相同。

### 8. 静态生命周期 `'static`

`'static` 是一种特殊的生命周期，表示引用可以存活整个程序运行期间。所有字符串字面量默认具有 `'static` 生命周期：

```rust
let s: &'static str = "I have a static lifetime.";
```

`'static` 生命周期通常用于全局变量或不随着函数调用结束而失效的引用。但要注意，避免滥用 `'static` 生命周期，可能导致悬空引用或生命周期误判。

### 9. 生命周期与闭包

在闭包中，生命周期会根据闭包的捕获模式和外部环境自动推断。闭包的生命周期遵循闭包的作用域，不需要显式声明。

```rust
fn apply_to_3<F>(f: F) -> i32
where
    F: Fn(i32) -> i32,
{
    f(3)
}
```

在这里，`apply_to_3` 接受一个闭包 `f`，闭包的生命周期由 Rust 自动推断和管理，确保闭包在调用过程中有效。

### 10. 高级用法：结合生命周期和泛型

生命周期和泛型可以组合使用，编写更加灵活的代码：

```rust
fn longest_with_generic<'a, T>(x: &'a str, y: &'a str, t: T) -> &'a str
where
    T: Display,
{
    println!("The generic value is: {}", t);
    if x.len() > y.len() { x } else { y }
}
```

在 `longest_with_generic` 函数中，`T` 是一个泛型，且实现了 `Display` trait。该函数接受两个生命周期为 `'a` 的引用和一个泛型参数 `t`。

### 11. 生命周期的性能

Rust 的生命周期在编译时分析，不会影响运行时性能。编译器会根据生命周期约束生成最优代码，避免了动态检查和开销。

### 总结

- **生命周期标注**：用于指定引用的有效作用范围，避免悬空引用。
- **省略规则**：Rust 编译器通过一系列省略规则自动推断生命周期标注。
- **结构体生命周期**：结构体中的引用字段需要生命周期标注。
- **静态生命周期 `'static`**：适用于程序期间全局有效的引用。
- **泛型与生命周期**：生命周期可与泛型参数结合，定义灵活的函数接口。

Rust 的生命周期在静态检查时帮助我们实现安全的内存管理，从而避免了大量动态检查和开销。理解生命周期是写出高效、可靠 Rust 程序的关键之一。