# FAQ

## tcp三次握手，一句话概括

客户端和服务端都需要直到各自可收发，因此需要三次握手。
简化三次握手：

从图片可以得到三次握手可以简化为：C 发起请求连接 S 确认，也发起连接 C 确认我们
再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受 C 发送的报文段第
二次握手：C 可以确认 S 收到了自己发送的报文段，并且可以确认 自己可以接受 S 发
送的报文段第三次握手：S 可以确认 C 收到了自己发送的报文段

## TCP和UDP的区别

（1）TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。
（2）TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，
不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，
面向连接，不会丢失数据因此适合大数据量的交换。
（3）TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低
（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。
（4）TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。
（5）TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。
（6）TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。

## HTTP请求的方式，HEAD方式

## 一个图片url访问后直接下载怎样实现？

## 说一下web Quality（无障碍）

## 几个很实用的BOM属性对象方法?

## 说一下HTML5 drag api

## 说一下http2.0

## 补充 400 和 401 、 403 状态码

## fetch发送 2 次请求的原因

## Cookie如何防范XSS攻击

## Cookie和session的区别

## 一句话概括RESTFUL

## 讲讲viewport和移动端布局

## click在ios上有300ms延迟，原因及如何解决？

## addEventListener参数

## cookie sessionStorage localStorage区别

## cookie session区别

## 介绍知道的http返回的状态码

## http常用请求头

## 讲讲强，协商缓存

## 强缓存、协商缓存什么时候用哪个

## 前端优化

## GET和POST的区别

## 和 302 的区别

## HTTP支持的方法

## 如何画一个三角形

## HTML5新增的元素

## 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？

## cookie和session的区别，localstorage和sessionstorage的区别

## 常见的HTTP的头部

## HTTP2.0 的特性

## cache-control的值有哪些

## 浏览器在生成页面的时候，会生成那两颗树？

## csrf和xss的网络攻击及防范

## 怎么看网站的性能如何

## 介绍HTTP协议(特征)

## 输入URL到页面加载显示完成发生了什么?

## 说一下对Cookie和Session的认知，Cookie有哪些限制？

## 描述一下XSS和CRSF攻击？防御方法？

## 知道 304 吗，什么时候用 304 ？

## 具体有哪些请求头是跟缓存相关的

## cookie和session的区别

## cookie有哪些字段可以设置

## cookie有哪些编码方式？

## 除了cookie，还有什么存储方式。说说cookie和localStorage的区别

## 浏览器输入网址到页面渲染全过程

## HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？

## http常见的请求方法

## get和post的区别

## 说说 302 ， 301 ， 304 的状态码

## web性能优化

## GET 和 POST 的请求的区别

1. 参数位置：GET 请求的参数是通过 URL 的查询字符串（query string）传递的，即参数会附加在 URL 的末尾。而 POST 请求的参数是通过请求的消息体（request body）传递的，参数不会直接显示在 URL 中。

2. 参数长度：由于 GET 请求的参数是附加在 URL 中的，所以参数长度受限于浏览器和服务器对 URL 长度的限制，通常在 2048 个字符左右。而 POST 请求的参数可以通过请求消息体传递，没有长度限制。

3. 安全性：GET 请求的参数会显示在 URL 中，因此不适合传递敏感信息，例如密码等。而 POST 请求的参数在消息体中，相对较安全，适合传递敏感信息。

4. 缓存：GET 请求默认可以被缓存，因为它的参数是显示在 URL 中的，浏览器可以直接使用缓存数据。而 POST 请求默认是不缓存的，因为它的参数不会显示在 URL 中，浏览器无法判断是否需要使用缓存数据。

5. 使用场景：GET 请求适用于请求数据，比如获取网页、图片等资源，以及向服务器查询数据。而 POST 请求适用于提交数据，比如用户登录、注册等操作，以及向服务器发送数据。

综上所述，GET 请求适合用于获取数据，参数较少且不敏感；而 POST 请求适合用于提交数据，参数较多且可能包含敏感信息。在实际应用中，根据请求的目的和数据的安全性来选择使用 GET 或 POST 方法。

## POST 和 PUT 请求的区别

1. 目的：POST 请求用于向服务器提交新的实体数据，通常用于创建资源。而 PUT 请求用于向服务器提交更新后的实体数据，通常用于更新资源。

2. 幂等性：POST 请求不具备幂等性，多次相同的 POST 请求会创建多个资源。而 PUT 请求具备幂等性，多次相同的 PUT 请求会更新同一资源，不会产生副作用。

3. 数据位置：POST 请求的数据是通过请求的消息体（request body）传递的，参数不会显示在 URL 中。而 PUT 请求的数据也是通过请求的消息体传递的，但通常会包含资源的标识符在 URL 中。

4. 资源标识符：对于 POST 请求，服务器通常会生成新的资源标识符，返回给客户端。而对于 PUT 请求，客户端需要在请求的 URL 中指定要更新的资源标识符。

5. 并发性：由于 PUT 请求具备幂等性，多个客户端同时发送相同的 PUT 请求不会产生冲突。而对于 POST 请求，多个客户端同时提交相同的数据可能会导致资源的创建冲突。

综上所述，POST 请求用于向服务器提交新的实体数据，不具备幂等性；而 PUT 请求用于向服务器提交更新后的实体数据，具备幂等性。正确选择 POST 或 PUT 请求取决于具体的应用场景和资源的创建或更新需求。

## 常见的 HTTP 请求方法

1. `GET`: 获取指定资源的信息。GET 请求通常用于从服务器获取数据，并不对服务器资源产生任何副作用。它应该是幂等的，多次请求相同的资源应该返回相同的结果。

2. `POST`: 在服务器上创建新的资源或提交数据。POST 请求通常用于提交表单数据或执行非幂等的操作。每次请求可能会创建新的资源或对服务器资源产生影响。

3. `PUT`: 更新服务器上的指定资源。PUT 请求通常用于更新已经存在的资源，其具备幂等性，多次相同的 PUT 请求应该对资源进行完全替换更新。

4. `DELETE`: 删除服务器上的指定资源。DELETE 请求用于删除服务器上的资源，其具备幂等性，多次相同的 DELETE 请求应该对资源产生相同的结果。

5. `PATCH`: 对服务器上的指定资源进行局部更新。PATCH 请求用于对资源的部分属性进行更新，而不是替换整个资源。它通常是非幂等的。

6. `HEAD`: 类似于 GET 请求，但只返回资源的头部信息而不返回实际内容。HEAD 请求用于获取资源的元数据，如响应状态、内容长度等。

7. `OPTIONS`: 查询服务器支持的请求方法。OPTIONS 请求用于检查服务器允许客户端使用的请求方法和其他可用功能。

8. `TRACE`: 回显服务器收到的请求，用于测试和诊断。

这些 HTTP 请求方法定义了客户端和服务器之间进行通信的不同方式，每种请求方法都有特定的语义和用途。在实际应用中，开发人员根据业务需求和 RESTful API 设计原则选择合适的请求方法。

## 常见的 HTTP 请求头和响应头

HTTP 请求头：

1. `User-Agent`: 浏览器或客户端的标识字符串，用于告知服务器发送请求的客户端类型和版本。
2. `Accept`: 告知服务器客户端可以接受的内容类型（MIME 类型），用于指定服务器返回的数据类型。
3. `Content-Type`: 请求消息体的数据类型（MIME 类型），用于指定发送给服务器的数据类型。
4. `Authorization`: 用于进行身份验证，通常在请求头中包含用户凭证，如 Basic Auth 或 Bearer Token。
5. `Referer`: 表示当前请求的来源页面 URL，通常用于防止跨站请求伪造 (CSRF) 攻击。
6. `Cookie`: 包含客户端的会话标识，用于在多个请求间维持状态。
7. `Cache-Control`: 控制请求/响应的缓存策略，如缓存的有效时间、是否强制重新验证等。
8. `Origin`: 指示请求的来源，用于支持跨域请求时进行 CORS 验证。

HTTP 响应头：

1. `Content-Type`: 响应消息体的数据类型（MIME 类型），用于指定返回的数据类型。
2. `Content-Length`: 响应消息体的长度，用于指示客户端正确解析响应内容。
3. `Cache-Control`: 控制响应的缓存策略，如缓存的有效时间、是否强制重新验证等。
4. `Set-Cookie`: 用于在响应头中设置客户端的 Cookie。
5. `Location`: 用于重定向响应，告知客户端新的资源位置。
6. `Access-Control-Allow-Origin`: 用于 CORS 验证，指定允许访问资源的源地址。
7. `ETag`: 用于缓存验证，表示资源的标识符，与 If-None-Match 一起用于条件请求。
8. `Content-Encoding`: 响应消息体的数据编码方式，如 gzip、deflate 等。

## Content-Type

`Content-Type` 是 HTTP 请求和响应头中的一个字段，用于指示消息体的数据类型，即请求或响应中携带的实际数据的格式。

在请求头中，`Content-Type` 用于指示客户端发送给服务器的数据类型，例如：

- `Content-Type: application/json`: 表示请求消息体中的数据是 JSON 格式。
- `Content-Type: application/x-www-form-urlencoded`: 表示请求消息体中的数据是 URL 编码表单数据。浏览器的原生 form 表 单 ， 如 果 不 设 置 enctype 属 性 ， 那 么 最 终 就 会 以 application/x-www-form-urlencoded 方式提交数据。该种方式提交 的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进 行编码，key 和 val 都进行了 URL 转码。
- `Content-Type: multipart/form-data`: 表示请求消息体中的数据是一个表单，通常用于上传文件。
- `Content-Type: text/plain`: 表示请求消息体中的数据是纯文本格式。

在响应头中，`Content-Type` 用于指示服务器返回给客户端的数据类型，例如：

- `Content-Type: application/json`: 表示响应消息体中的数据是 JSON 格式。
- `Content-Type: text/html`: 表示响应消息体中的数据是 HTML 格式。
- `Content-Type: image/jpeg`: 表示响应消息体中的数据是 JPEG 图像。
- `Content-Type: application/octet-stream`: 表示响应消息体中的数据是二进制数据，通常用于下载文件。

## HTTP 1.1 和 HTTP 2.0 的区别

## HTTP 和 HTTPS 协议的区别

## HTTP2 的头部压缩算法是怎样的？

## 说一下 HTTP 3.0

## 什么是 HTTPS 协议？

## HTTPS 通信（握手）过程

## DNS 完整的查询过程

## OSI 七层模型

## 谈一谈http的缺点

虽然 HTTP（Hypertext Transfer Protocol）是现代网络通信的基础之一，但它也存在一些缺点。以下是一些常见的 HTTP 缺点：

1. **无状态：** HTTP 协议是无状态的，每个请求之间没有关联。这意味着服务器无法识别两个请求是否来自同一个客户端，需要额外的机制（如 Cookies 或 Tokens）来维护用户状态。

2. **明文传输：** HTTP 在传输过程中是明文的，容易受到中间人攻击。未加密的通信可能导致敏感信息泄露，因此需要使用 HTTPS 进行加密。

3. **性能：** 在传输大量数据时，HTTP 的性能可能受到影响。每个请求都需要建立连接、发送请求头等，这会导致额外的延迟。这在移动网络或高延迟环境下尤为明显。

4. **单向通信：** HTTP 是一种单向通信协议，只允许客户端发起请求，服务器只能响应。这种单向性可能不适用于一些实时性要求较高的应用场景。

5. **Header 大小：** HTTP 请求和响应的 Header 大小是有限制的，对于包含大量 Header 信息的复杂请求，可能需要进行优化或者采用其他机制。

6. **连接保持问题：** 默认情况下，HTTP 是一种短连接协议，每个请求都需要重新建立连接。虽然 HTTP/1.1 引入了持久连接（Keep-Alive），但仍然存在一些连接保持的管理问题，如连接过早关闭或过度打开的问题。

7. **缺乏推送机制：** HTTP 是一种请求-响应模型，服务器不能主动向客户端推送数据。虽然有一些工具和技术可以模拟推送效果，但它们通常需要使用轮询或长连接等机制。

8. **无法处理复杂的事务：** 在某些场景下，HTTP 无法提供足够的支持，例如，对于需要处理复杂事务和事务回滚的系统，HTTP 可能显得力不从心。

尽管 HTTP 存在这些缺点，但它仍然是互联网通信的基石。为了解决其中一些问题，一些新的协议和技术如 HTTP/2、HTTP/3、WebSocket 等被引入，以提高性能、安全性和实时性。

## http跨域时的options请求

## TCP和UDP的区别

UDP（User Datagram Protocol）和TCP（Transmission Control Protocol）是两种不同的传输层协议，它们在网络通信中有一些显著的区别：

1. **连接性：**
   - **TCP：** 提供面向连接的通信，建立可靠的、全双工的连接。在数据传输前，必须经过三次握手建立连接，保证数据的可靠性，然后通过四次挥手关闭连接。
   - **UDP：** 无连接的通信，发送数据前不需要建立连接，也不保证可靠性。每个UDP数据包都是一个独立的数据单元，相互之间没有关联。

2. **可靠性：**
   - **TCP：** 提供可靠的数据传输，通过序列号、确认和重传机制来确保数据的完整性和有序性。如果数据包丢失或损坏，TCP会尝试重新发送。
   - **UDP：** 不保证可靠性，数据包可能会丢失或到达顺序可能被打乱。UDP更适用于实时性要求较高的应用，如音视频传输。

3. **数据流：**
   - **TCP：** 提供面向字节流的通信，数据被视为字节流，确保有序且不丢失。
   - **UDP：** 数据被分割成数据包，每个数据包都是独立的，UDP对数据包的处理更为简单。

4. **开销：**
   - **TCP：** 需要较多的开销来维护连接状态、序列号、确认等，适用于要求可靠性和完整性的应用。
   - **UDP：** 开销较小，适用于实时性要求高、可以容忍一些数据丢失的应用。

5. **应用场景：**
   - **TCP：** 适用于需要可靠传输的应用，如文件传输、网页访问等。
   - **UDP：** 适用于实时性要求高、可以容忍一些数据丢失的应用，如音视频传输、在线游戏等。

总体而言，选择使用TCP还是UDP取决于具体的应用需求。TCP适用于对数据可靠性有较高要求的场景，而UDP适用于实时性要求高、对数据完整性要求相对较低的场景。

## http/https协议总结

## 正向代理和反向代理

## DNS如何工作的

DNS（Domain Name System）是一种用于将域名映射到IP地址的分布式命名系统。DNS的工作涉及多个组件，包括客户端、本地DNS服务器、根域名服务器、顶级域名服务器和授权域名服务器。以下是DNS工作的基本过程：

1. **域名解析请求：** 当用户在浏览器中输入一个域名（例如，www.example.com）并按下Enter键时，计算机首先尝试查找这个域名对应的IP地址。

2. **本地DNS缓存：** 操作系统会首先检查本地的DNS缓存，看是否已经缓存了对应域名的IP地址。如果找到了，就直接使用缓存的IP地址。

3. **本地DNS服务器：** 如果本地缓存中没有找到对应的IP地址，计算机会向本地DNS服务器发起解析请求。本地DNS服务器通常由Internet服务提供商（ISP）提供，也可以是自己配置的其他DNS服务器。

4. **根域名服务器：** 如果本地DNS服务器无法直接解析请求，它将向根域名服务器发送查询。根域名服务器是全球DNS体系的顶级，负责管理顶级域名服务器的IP地址。

5. **顶级域名服务器：** 根域名服务器返回一个指向相应顶级域名服务器的IP地址。例如，在解析www.example.com时，它会指向.com顶级域名服务器。

6. **授权域名服务器：** 顶级域名服务器返回一个指向授权域名服务器的IP地址，负责管理该域的二级域名。在这个例子中，授权域名服务器可能指向管理example.com的域名服务器。

7. **目标域名服务器：** 最终，授权域名服务器返回请求域名的IP地址给本地DNS服务器。本地DNS服务器将这个IP地址缓存，并将其返回给计算机。

8. **计算机：** 最后，计算机得到了域名对应的IP地址，可以使用这个IP地址与目标服务器进行通信。

这个过程中，DNS采用了分布式的设计，将域名解析的任务分散到多个层次的服务器上，以提高效率和可靠性。每个层次的DNS服务器都负责管理一部分域名系统，从而实现了对整个互联网域名系统的管理。

## HTTP/1.0 HTTP1.1 HTTP2.0版本之间的差异

## HTTP/1.0 HTTP1.1 HTTP2.0区别

## Websocket和HTTP协议有什么区别

## HTTP跨域请求时为什么要发送options请求

## HTTP3

## 谈一谈你对HTTP/2理解

## SSL 连接断开后如何恢复

## 介绍一个HTTPS工作原理

## HTTPS握手过程

## 介绍一下HTTPS和HTTP区别

## Http请求中token cookie 和 session有什么区别

## 谈一谈HTTP数据传输

## 谈一谈队头阻塞问题

## HTTP实体数据

## HTTP前生今世

HTTP（Hypertext Transfer Protocol）是一种用于传输超文本的协议，是万维网（World Wide Web）的基础。HTTP的发展经历了多个版本，从初始的HTTP/0.9到目前主流的HTTP/1.1和HTTP/2，以及更新的HTTP/3。以下是HTTP的前世今生的简要概述：

### HTTP/0.9（1991年）

- **特点：** 初始版本，仅支持GET请求，没有Header，只能传输HTML。
- **用途：** 用于简单的文本传输，适用于静态网页。

### HTTP/1.0（1996年）

- **特点：** 引入了多种HTTP方法（GET、POST等）、Header、状态码、协议版本号等。
- **用途：** 用于传输更丰富的内容，支持动态生成页面和多媒体文件。

### HTTP/1.1（1997年）

- **特点：** 持久连接、管线化、虚拟主机等新特性，提高了性能。
- **用途：** 成为当前主流的HTTP版本，用于绝大多数Web应用。

### HTTP/2（2015年）

- **特点：** 多路复用、头部压缩、服务器推送等新特性，提高了性能和效率。
- **用途：** 通过单一连接并行传输多个资源，减少了加载时间，适用于现代Web应用。

### HTTP/3（2018年）

- **特点：** 基于UDP的QUIC协议，实现更低的延迟和更高的性能。
- **用途：** 在不同网络条件下提供更好的性能，支持实时应用。

### 发展趋势

1. **安全性：** HTTPS的推广和强制，使用TLS/SSL保护通信内容，提高数据传输的安全性。

2. **性能优化：** 不断推出新的协议版本和特性，如HTTP/2、HTTP/3，以提高传输效率和用户体验。

3. **移动端优化：** 针对移动设备的特性进行优化，减少页面加载时间和资源消耗。

4. **Web应用需求：** 随着Web应用的复杂性增加，HTTP协议会不断演进以满足更复杂的业务需求，例如大规模数据传输、实时通信等。

总体而言，HTTP协议的演进是为了适应互联网的不断发展和应对新的挑战。由于Web应用越来越复杂，HTTP协议的性能和安全性一直是关注的焦点。

## HTTP世界全览

## HTTP分层

## HTTP报文是什么样子

HTTP报文是在客户端和服务器之间传输的数据块，它包括请求报文和响应报文。以下是HTTP请求和响应报文的一般结构：

### HTTP请求报文

一个HTTP请求报文通常由以下部分组成：

1. **请求行（Request Line）：** 包含HTTP方法（GET、POST等）、请求的URL和使用的协议版本。

   ```
   GET /path/to/resource HTTP/1.1
   ```

2. **请求头部（Request Headers）：** 包含关于请求的附加信息，如Host、User-Agent、Content-Type等。

   ```
   Host: www.example.com
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
   Content-Type: application/json
   ```

3. **空行（CRLF）：** 表示请求头部的结束，用一个空行（回车换行符）分隔请求头部和请求体。

   ```
   (空行)
   ```

4. **请求体（Request Body）：** 对于一些HTTP方法（如POST、PUT），可以包含请求的数据。

   ```
   {"key": "value"}
   ```

### HTTP响应报文

一个HTTP响应报文通常由以下部分组成：

1. **状态行（Status Line）：** 包含协议版本、状态码和状态消息。

   ```
   HTTP/1.1 200 OK
   ```

2. **响应头部（Response Headers）：** 包含关于响应的附加信息，如Server、Content-Type、Content-Length等。

   ```
   Server: Apache/2.4.38 (Unix)
   Content-Type: text/html; charset=UTF-8
   Content-Length: 1234
   ```

3. **空行（CRLF）：** 表示响应头部的结束，用一个空行（回车换行符）分隔响应头部和响应体。

   ```
   (空行)
   ```

4. **响应体（Response Body）：** 包含服务器返回的数据。

   ```
   <html>
     <head>
       <title>Hello, World!</title>
     </head>
     <body>
       <h1>Hello, World!</h1>
     </body>
   </html>
   ```

上述结构是HTTP报文的基本组成部分，实际的报文内容和头部字段会根据具体的请求或响应而有所变化。HTTP报文的设计是为了传输和描述Web页面及其相关资源的信息。

## HTTP之URL

## 什么是https中间人攻击，如何预防（HTTPS加密过程、原理）

## HTTP协议的主要特点

简单快速、灵活、无连接、无状态

## HTTP报文的组成部分

## 持久链接/http长链接

## 长链接中的管线化

## HTTP 报文的组成部分

## 常见状态码

## 从输入URL到呈现页面过程

## UDP 和 TCP有什么区别

## TCP为什么要三次握手

## 三次握手过程中可以携带数据吗

## TCP的四次挥手

## TCP 和 UDP 的区别

## HTTP和TCP的不同

## HTTP2相关

## 说一下 http2.0

## HTTP2和HTTP1有什么区别

## http/2为什么要做头部压缩，实现原理是什么？

## http/2的Server Push有什么优点

## 谈谈你对多路复用的理解

## https相关

## HTTPS加的一层SSL在七层中哪个位置

## https 协议的优点

## https 协议的缺点

## http与https区别

## https传输的具体过程

## HTTPS的整体过程分为证书验证和数据传输阶段

## 介绍一下https的握手过程

## 为什么https数据传输使用对称加密

## 介绍下https中间人攻击的过程

## HTTPS 握手过程中，客户端如何验证证书的合法性

## 问题

## 数字签名？它是什么

## 谈谈对数字证书的理解

## 为什么说数字证书就能对通信方的身份进行验证呢

## 请详细的说一下HTTPS它的加密传输过程，涉及到哪些算法呢？

## 描述一下RSA握手

## ECDHE握手和RSA握手又有什么区别呢

## 你知道TSL1.3版本吗？它较TSL1.2做了哪些改进呢？

## 介绍下 HTTPS 中间人攻击

## http/https 协议总结

## WebSocket的实现和应用

## 什么是 WebSocket

## WebSocket 是什么样的协议，具体有什么优点

## 理解WebSocket协议的底层原理、与HTTP的区别

## Token、cookie、Session区别

## cookie 和 token 都存放在 header 中，为什么不会劫持 token？

## 介绍下如何实现 token 加密

## 一个图片 url 访问后直接下载怎样实现

## fetch 发送 2 次请求的原因

## GET 和 POST 的区别

## 301和 302 的区别

## DNS的作用、DNS解析的详细过程，DNS优化原理

## 简单请求和复杂请求

## Http请求中的keep-alive有了解吗

## 管道机制的作用是什么

## 什么情况下会触发option请求

## GET可以上传图片吗

## CDN的作用和原理

## 如何捕获CDN上的js运行时导致的详细错误信息？

## 强缓存命中发生了什么？

## 默认的强制缓存时间是多少？

## CORS跨域的原理

## CORS的哪些是简单请求？

## CORS的预检请求具体是怎样的？

## 为什么简单请求不需要预检？

## 复杂请求预检检查什么东西？

## 如果CORS附带身份凭证要怎样做？

## 如何减少CORS预请求的次数？

## 在深圳的网页上输入百度，是怎么把这个请求发到北京的

## 为什么使用多域名部署？

## 页面10张img，http1是怎样的加载表现？怎样解决的？

## 说一说SSO单点登录

## 说一说OAuth

## HTTP传输大文件

## HTTP的代理服务

- 负载均衡： 代理服务器可以分发客户端请求到多个目标服务器，以实现负载均衡。这有助于提高系统的可伸缩性和性能。
- 健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；
- 安全防护：保护被代理的后端服务器，限制 IP地址或流量，抵御网络攻击和过载；
- 加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；
- 数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；
- 内容缓存：暂存、复用服务器响应
