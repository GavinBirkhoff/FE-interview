# FAQ

## tcp三次握手，一句话概括

客户端和服务端都需要直到各自可收发，因此需要三次握手。
简化三次握手：

从图片可以得到三次握手可以简化为：C 发起请求连接 S 确认，也发起连接 C 确认我们
再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受 C 发送的报文段第
二次握手：C 可以确认 S 收到了自己发送的报文段，并且可以确认 自己可以接受 S 发
送的报文段第三次握手：S 可以确认 C 收到了自己发送的报文段

## TCP和UDP的区别

（1）TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。
（2）TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，
不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，
面向连接，不会丢失数据因此适合大数据量的交换。
（3）TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低
（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。
（4）TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。
（5）TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。
（6）TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。

## HTTP请求的方式，HEAD方式

## 一个图片url访问后直接下载怎样实现？

## 说一下web Quality（无障碍）

## 几个很实用的BOM属性对象方法?

## 说一下HTML5 drag api

## 说一下http2.0

## 补充 400 和 401 、 403 状态码

## fetch发送 2 次请求的原因

## Cookie、sessionStorage、localStorage的区别

## 说一下web worker

## 对HTML语义化标签的理解

## iframe是什么？有什么缺点？

## Doctype作用?严格模式与混杂模式如何区分？它们有何意义?

## Cookie如何防范XSS攻击

## Cookie和session的区别

## 一句话概括RESTFUL

## 讲讲viewport和移动端布局

## click在ios上有300ms延迟，原因及如何解决？

## addEventListener参数

## cookie sessionStorage localStorage区别

## cookie session区别

## 介绍知道的http返回的状态码

## http常用请求头

## 讲讲强，协商缓存

## 强缓存、协商缓存什么时候用哪个

## 前端优化

## GET和POST的区别

## 301 和 302 的区别

## HTTP支持的方法

## 如何画一个三角形

## 状态码 304 和

## 说一下浏览器缓存

## HTML5新增的元素

## 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？

## cookie和session的区别，localstorage和sessionstorage的区别

## 常见的HTTP的头部

## HTTP2.0 的特性

## cache-control的值有哪些

## 浏览器在生成页面的时候，会生成那两颗树？

## csrf和xss的网络攻击及防范

## 怎么看网站的性能如何

## 介绍HTTP协议(特征)

## 输入URL到页面加载显示完成发生了什么?

## 说一下对Cookie和Session的认知，Cookie有哪些限制？

## 描述一下XSS和CRSF攻击？防御方法？

## 知道 304 吗，什么时候用 304 ？

## 具体有哪些请求头是跟缓存相关的

## cookie和session的区别

## cookie有哪些字段可以设置

## cookie有哪些编码方式？

## 除了cookie，还有什么存储方式。说说cookie和localStorage的区别

## 浏览器输入网址到页面渲染全过程

## HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？

## http常见的请求方法

## get和post的区别

## 说说 302 ， 301 ， 304 的状态码

## web性能优化

## GET 和 POST 的请求的区别

1. 参数位置：GET 请求的参数是通过 URL 的查询字符串（query string）传递的，即参数会附加在 URL 的末尾。而 POST 请求的参数是通过请求的消息体（request body）传递的，参数不会直接显示在 URL 中。

2. 参数长度：由于 GET 请求的参数是附加在 URL 中的，所以参数长度受限于浏览器和服务器对 URL 长度的限制，通常在 2048 个字符左右。而 POST 请求的参数可以通过请求消息体传递，没有长度限制。

3. 安全性：GET 请求的参数会显示在 URL 中，因此不适合传递敏感信息，例如密码等。而 POST 请求的参数在消息体中，相对较安全，适合传递敏感信息。

4. 缓存：GET 请求默认可以被缓存，因为它的参数是显示在 URL 中的，浏览器可以直接使用缓存数据。而 POST 请求默认是不缓存的，因为它的参数不会显示在 URL 中，浏览器无法判断是否需要使用缓存数据。

5. 使用场景：GET 请求适用于请求数据，比如获取网页、图片等资源，以及向服务器查询数据。而 POST 请求适用于提交数据，比如用户登录、注册等操作，以及向服务器发送数据。

综上所述，GET 请求适合用于获取数据，参数较少且不敏感；而 POST 请求适合用于提交数据，参数较多且可能包含敏感信息。在实际应用中，根据请求的目的和数据的安全性来选择使用 GET 或 POST 方法。

## POST 和 PUT 请求的区别

1. 目的：POST 请求用于向服务器提交新的实体数据，通常用于创建资源。而 PUT 请求用于向服务器提交更新后的实体数据，通常用于更新资源。

2. 幂等性：POST 请求不具备幂等性，多次相同的 POST 请求会创建多个资源。而 PUT 请求具备幂等性，多次相同的 PUT 请求会更新同一资源，不会产生副作用。

3. 数据位置：POST 请求的数据是通过请求的消息体（request body）传递的，参数不会显示在 URL 中。而 PUT 请求的数据也是通过请求的消息体传递的，但通常会包含资源的标识符在 URL 中。

4. 资源标识符：对于 POST 请求，服务器通常会生成新的资源标识符，返回给客户端。而对于 PUT 请求，客户端需要在请求的 URL 中指定要更新的资源标识符。

5. 并发性：由于 PUT 请求具备幂等性，多个客户端同时发送相同的 PUT 请求不会产生冲突。而对于 POST 请求，多个客户端同时提交相同的数据可能会导致资源的创建冲突。

综上所述，POST 请求用于向服务器提交新的实体数据，不具备幂等性；而 PUT 请求用于向服务器提交更新后的实体数据，具备幂等性。正确选择 POST 或 PUT 请求取决于具体的应用场景和资源的创建或更新需求。

## 常见的 HTTP 请求方法

1. `GET`: 获取指定资源的信息。GET 请求通常用于从服务器获取数据，并不对服务器资源产生任何副作用。它应该是幂等的，多次请求相同的资源应该返回相同的结果。

2. `POST`: 在服务器上创建新的资源或提交数据。POST 请求通常用于提交表单数据或执行非幂等的操作。每次请求可能会创建新的资源或对服务器资源产生影响。

3. `PUT`: 更新服务器上的指定资源。PUT 请求通常用于更新已经存在的资源，其具备幂等性，多次相同的 PUT 请求应该对资源进行完全替换更新。

4. `DELETE`: 删除服务器上的指定资源。DELETE 请求用于删除服务器上的资源，其具备幂等性，多次相同的 DELETE 请求应该对资源产生相同的结果。

5. `PATCH`: 对服务器上的指定资源进行局部更新。PATCH 请求用于对资源的部分属性进行更新，而不是替换整个资源。它通常是非幂等的。

6. `HEAD`: 类似于 GET 请求，但只返回资源的头部信息而不返回实际内容。HEAD 请求用于获取资源的元数据，如响应状态、内容长度等。

7. `OPTIONS`: 查询服务器支持的请求方法。OPTIONS 请求用于检查服务器允许客户端使用的请求方法和其他可用功能。

8. `TRACE`: 回显服务器收到的请求，用于测试和诊断。

这些 HTTP 请求方法定义了客户端和服务器之间进行通信的不同方式，每种请求方法都有特定的语义和用途。在实际应用中，开发人员根据业务需求和 RESTful API 设计原则选择合适的请求方法。

## 常见的 HTTP 请求头和响应头

HTTP 请求头：

1. `User-Agent`: 浏览器或客户端的标识字符串，用于告知服务器发送请求的客户端类型和版本。
2. `Accept`: 告知服务器客户端可以接受的内容类型（MIME 类型），用于指定服务器返回的数据类型。
3. `Content-Type`: 请求消息体的数据类型（MIME 类型），用于指定发送给服务器的数据类型。
4. `Authorization`: 用于进行身份验证，通常在请求头中包含用户凭证，如 Basic Auth 或 Bearer Token。
5. `Referer`: 表示当前请求的来源页面 URL，通常用于防止跨站请求伪造 (CSRF) 攻击。
6. `Cookie`: 包含客户端的会话标识，用于在多个请求间维持状态。
7. `Cache-Control`: 控制请求/响应的缓存策略，如缓存的有效时间、是否强制重新验证等。
8. `Origin`: 指示请求的来源，用于支持跨域请求时进行 CORS 验证。

HTTP 响应头：

1. `Content-Type`: 响应消息体的数据类型（MIME 类型），用于指定返回的数据类型。
2. `Content-Length`: 响应消息体的长度，用于指示客户端正确解析响应内容。
3. `Cache-Control`: 控制响应的缓存策略，如缓存的有效时间、是否强制重新验证等。
4. `Set-Cookie`: 用于在响应头中设置客户端的 Cookie。
5. `Location`: 用于重定向响应，告知客户端新的资源位置。
6. `Access-Control-Allow-Origin`: 用于 CORS 验证，指定允许访问资源的源地址。
7. `ETag`: 用于缓存验证，表示资源的标识符，与 If-None-Match 一起用于条件请求。
8. `Content-Encoding`: 响应消息体的数据编码方式，如 gzip、deflate 等。

## Content-Type

`Content-Type` 是 HTTP 请求和响应头中的一个字段，用于指示消息体的数据类型，即请求或响应中携带的实际数据的格式。

在请求头中，`Content-Type` 用于指示客户端发送给服务器的数据类型，例如：

- `Content-Type: application/json`: 表示请求消息体中的数据是 JSON 格式。
- `Content-Type: application/x-www-form-urlencoded`: 表示请求消息体中的数据是 URL 编码表单数据。浏览器的原生 form 表 单 ， 如 果 不 设 置 enctype 属 性 ， 那 么 最 终 就 会 以 application/x-www-form-urlencoded 方式提交数据。该种方式提交 的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进 行编码，key 和 val 都进行了 URL 转码。
- `Content-Type: multipart/form-data`: 表示请求消息体中的数据是一个表单，通常用于上传文件。
- `Content-Type: text/plain`: 表示请求消息体中的数据是纯文本格式。

在响应头中，`Content-Type` 用于指示服务器返回给客户端的数据类型，例如：

- `Content-Type: application/json`: 表示响应消息体中的数据是 JSON 格式。
- `Content-Type: text/html`: 表示响应消息体中的数据是 HTML 格式。
- `Content-Type: image/jpeg`: 表示响应消息体中的数据是 JPEG 图像。
- `Content-Type: application/octet-stream`: 表示响应消息体中的数据是二进制数据，通常用于下载文件。
