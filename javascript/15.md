# 原型链

原型是通过__proto__指向的，把原型连接成链就叫原型链，原型链记录了原型创建对象的整个过程，原型链是原型创建对象的历史记录。

## JS如何实现继承？

**第一种: 借助call**

```js
  function Parent1(){
    this.name = 'parent1';
  }
  function Child1(){
    Parent1.call(this);
    this.type = 'child1'
  }
  console.log(new Child1);
```

这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。

**第二种: 借助原型链**

```js
  function Parent2() {
    this.name = 'parent2';
    this.play = [1, 2, 3]
  }
  function Child2() {
    this.type = 'child2';
  }
  Child2.prototype = new Parent2();
 
  console.log(new Child2());
```

看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：

```js
  var s1 = new Child2();
  var s2 = new Child2();
  s1.play.push(4);
  console.log(s1.play, s2.play);
```

**第三种：将前两种组合**

```js
  function Parent3 () {
    this.name = 'parent3';
    this.play = [1, 2, 3];
  }
  function Child3() {
    Parent3.call(this);
    this.type = 'child3';
  }
  Child3.prototype = new Parent3();
  var s3 = new Child3();
  var s4 = new Child3();
  s3.play.push(4);
  console.log(s3.play, s4.play);
```

之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？

**第四种: 组合继承的优化1**

```js
  function Parent4 () {
    this.name = 'parent4';
    this.play = [1, 2, 3];
  }
  function Child4() {
    Parent4.call(this);
    this.type = 'child4';
  }
  Child4.prototype = Parent4.prototype;
```

这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：

```js
  var s3 = new Child4();
  var s4 = new Child4();
  console.log(s3)
```

子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。

**第五种(最推荐使用): 组合继承的优化1**

```js
  function Parent5 () {
    this.name = 'parent5';
    this.play = [1, 2, 3];
  }
  function Child5() {
    Parent5.call(this);
    this.type = 'child5';
  }
  Child5.prototype = Object.create(Parent5.prototype);
  Child5.prototype.constructor = Child5;
```

这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。

ES6的extends被编译后的JavaScript代码 TODO

## 实现new

要创建一个实例，应该使用new操作符，用new来调用构造函数会执行如下操作

1. 创建一个新对象；
2. 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性，实现继承
3. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
4. 执行构造函数中的代码（为这个新对象添加属性）；
5. 返回新对象，如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。

```js
function _new(fn, ...arg) {
     const obj = {}; //创建一个新的对象
     obj.__proto__ = fn.prototype; //把obj的__proto__指向fn的prototype,实现继承
     fn.apply(obj, arg) //改变this的指向
     return Object.prototype.toString.call(obj) == '[object Object]'? obj : {} //返回新的对象obj
 }
 ```

所以，这也是为什么new可以改变this指向的原因，回答了刚刚开始的时候那个问题
