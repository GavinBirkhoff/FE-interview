# 原型链

原型是通过__proto__指向的，把原型连接成链就叫原型链，原型链记录了原型创建对象的整个过程，原型链是原型创建对象的历史记录。

## JS如何实现继承？

**第一种: 借助call**

```js
  function Parent1(){
    this.name = 'parent1';
  }
  function Child1(){
    Parent1.call(this);
    this.type = 'child1'
  }
  console.log(new Child1);
```

这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。

**第二种: 借助原型链**

```js
  function Parent2() {
    this.name = 'parent2';
    this.play = [1, 2, 3]
  }
  function Child2() {
    this.type = 'child2';
  }
  Child2.prototype = new Parent2();
 
  console.log(new Child2());
```

看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：

```js
  var s1 = new Child2();
  var s2 = new Child2();
  s1.play.push(4);
  console.log(s1.play, s2.play);
```

**第三种：将前两种组合**

```js
  function Parent3 () {
    this.name = 'parent3';
    this.play = [1, 2, 3];
  }
  function Child3() {
    Parent3.call(this);
    this.type = 'child3';
  }
  Child3.prototype = new Parent3();
  var s3 = new Child3();
  var s4 = new Child3();
  s3.play.push(4);
  console.log(s3.play, s4.play);
```

之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？

**第四种: 组合继承的优化1**

```js
  function Parent4 () {
    this.name = 'parent4';
    this.play = [1, 2, 3];
  }
  function Child4() {
    Parent4.call(this);
    this.type = 'child4';
  }
  Child4.prototype = Parent4.prototype;
```

这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：

```js
  var s3 = new Child4();
  var s4 = new Child4();
  console.log(s3)
```

子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。

**第五种(最推荐使用): 组合继承的优化1**

```js
  function Parent5 () {
    this.name = 'parent5';
    this.play = [1, 2, 3];
  }
  function Child5() {
    Parent5.call(this);
    this.type = 'child5';
  }
  Child5.prototype = Object.create(Parent5.prototype);
  Child5.prototype.constructor = Child5;
```

这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。

ES6的extends被编译后的JavaScript代码 TODO

## 实现new

要创建一个实例，应该使用new操作符，用new来调用构造函数会执行如下操作

1. 创建一个新对象；
2. 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性，实现继承
3. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
4. 执行构造函数中的代码（为这个新对象添加属性）；
5. 返回新对象，如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。

```js
function _new(fn, ...arg) {
     const obj = {}; //创建一个新的对象
     obj.__proto__ = fn.prototype; //把obj的__proto__指向fn的prototype,实现继承
     fn.apply(obj, arg) //改变this的指向
     return Object.prototype.toString.call(obj) == '[object Object]'? obj : {} //返回新的对象obj
 }
```

所以，这也是为什么new可以改变this指向的原因，回答了刚刚开始的时候那个问题

## Object.create 和 new 有什么区别？

js中创建对象的方式一般有两种Object.create和new

```
1const Base = function(){};
2const o1 = Object.create(Base);
3const o2 = new Base();
```

在讲述两者区别之前，我们需要知道：

- 构造函数Foo的原型属性Foo.prototype指向了原型对象。
- 原型对象保存着实例共享的方法，有一个指针constructor指回构造函数。
- js中只有函数有 prototype 属性，所有的对象只有 **proto** 隐式属性。

那这样到底有什么不一样呢？

## Object.create

先来看看 `Object.create` 的实现方式

```
1Object.create =  function (o) {
2    var F = function () {};
3    F.prototype = o;
4    return new F();
5};
```

可以看出来。Object.create是内部定义一个对象，并且让F.prototype对象 赋值为引进的对象/函数 o，并return出一个新的对象。

## new

再看看 `const o2 = new Base()` 的时候，new做了什么。

```
1var o1 = new Object();
2o1.[[Prototype]] = Base.prototype;
3Base.call(o1);
```

new做法是新建一个obj对象o1，并且让o1的__proto__指向了Base.prototype对象。并且使用 call 进行强转作用环境。从而实现了实例的创建。

## 区别

看似是一样的。我们对原来的代码进行改进一下。

```
1var Base = function () {
2    this.a = 2
3}
4var o1 = new Base();
5var o2 = Object.create(Base);
6console.log(o1.a); // 2
7console.log(o2.a); // undefined
```

可以看到Object.create 失去了原来对象的属性的访问。

再进行下改造：

```
1var Base = function () {
2    this.a = 2
3}
4Base.prototype.a = 3;
5var o1 = new Base();
6var o2 = Object.create(Base);
7console.log(o1.a); // 2
8console.log(o2.a); // undefined
```

## 小结

小结

| 比较     | new                     | Object.create           |
| -------- | ----------------------- | ----------------------- |
| 构造函数 | 保留原构造函数属性      | 丢失原构造函数属性      |
| 原型链   | 原构造函数prototype属性 | 原构造函数/（对象）本身 |
| 作用对象 | function                | function和object        |
