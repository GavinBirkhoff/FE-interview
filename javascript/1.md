# 闭包

### 闭包的概念

闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

**闭包是指有权访问另一个函数作用域中的变量的函数**

闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。

### 实用的闭包

闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。

### 词法作用域

JavaScript 实现了一种名为词法作用域（或静态作用域）的作用域机制。它被称为词法（或静态），因为引擎仅通过查看 JavaScript 源代码来确定范围的嵌套，无论它在哪里调用。

```js
var a = 10;
function foo() {
  console.log(a); // 10
}

function bar() {
  var a = 20;
  foo();
}

bar();
```

```js
var a = 10;

function bar() {
  var a = 20;

  function foo() {
    console.log(a); // 20
  }

  foo();
}

bar();
```

### 闭包的作用

1. 函数再执行完以后，函数内部声明的局部变量依旧存在内存中，未被回收（延长了局部变量的生命周期）；
2. 在函数外部可以直接访问（操作）函数内部的局部变量；暴露内部变量，暴露指定方法（内部函数），使得外部可以使用指定的方法读取或者操作内部变量。
3. 闭包对象一直存在的原因：
fn2没有被引用，函数执行完会自动释放；fn3这个变量会自动释放，f指向fn3这个函数对象的地址，函数对象又关联着闭包对象，所以闭包对象不会被回收（有f还引用着它）。

```js
function fn1(){
    var a = 2
    function fn2(){
        a++
        console.log(a);
    }
    function fn3(){
        a--
        console.log(a);
    }
    debugger
    return fn3
}

var f = fn1()
f()
f()
```

### 闭包的生命周期

产生：嵌套内部函数声明完成时就会产生闭包对象
销毁：嵌套内部函数成为垃圾对象（null）

函数声明式定义内部函数

```js
function fn1(){
    // 此时闭包就已经产生了（函数提升，内部函数对象已经创建）
    var a = 2
    function fn2(){
        a++
        console.log(a);
    }
    function fn3(){
        a--
        console.log(a);
    }
    debugger
    return fn3
}

var f = fn1()
f()
f()
f = null // 闭包销毁，包含闭包的函数对象成为垃圾对象
```

函数表达式（匿名函数）定义内部函数

```js
function fn1(){
    var a = 2
    function fn2(){
        a++
        console.log(a);
    }
    var fn3 = function (){ // 只有运行到这里才产生闭包对象
        a--
        console.log(a);
    }
    return fn3
}

var f = fn1()
f()
f()
f=null
```

### 闭包的应用

可以定义JS模块
具有特定功能的js文件，将所有数据和功能封装在函数内部（私有），只对外暴露一个内部函数或者包含多个内部函数的对象，模块的使用者，只需要通过调用模块中暴露的函数或者对象中的函数，来实现对应的功能。

定义模块

```js
function myModule(){
    var msg = 'message'
    function getMsg(){
        console.log(msg);
    }
    return {
        getMsg
    }
}
```

IFFE

```js
(function (window){
    var msg = 'message'
    function getMsg(){
        console.log(msg);
    }
    window.myModule = {
        getMsg
    }
})(window)
```

### 闭包的缺点

- 函数执行完后，函数内部的局部变量没有释放，占用内存事件长，容易导致内存泄漏（占用内存没有被及时释放）。
- 当需要内存太大，超出剩余内存时，就会内存溢出（页面崩溃直接报错）。

>少用闭包，及时释放内存，用完后赋值为null，让内部函数成为垃圾对象，回收闭包当需要内存太大

### 闭包测试题

```js
var name = "The window"
var obj = {
    name:"My Object",
    getNameFunc: function(){ // 没有闭包对象
        return function(){ // 里面的this指向window,匿名函数外层的this指向obj
            return this.name
        }
    }
}
console.log(obj.getNameFunc()()); // The window

var obj1 = {
    name:"My Object",
    getNameFunc: function(){ // 存在闭包对象
        var that = this
        return function(){
            return that.name
        }
    }
}
console.log(obj1.getNameFunc()()); // My Object

var obj2 = {
    name:"My Object",
    getNameFunc: function(){ // 没有闭包对象
        return ()=>{ // 箭头函数没有this,匿名函数外层的this指向obj
            return this.name
        }
    }
}
console.log(obj2.getNameFunc()()); // My Object
```

```js
function fun(n,o){
    console.log(o);
    return {
        fun:function(m){
            return fun(m,n)
        }
    }

}

var a = fun(0) // undefined
a.fun(1) // 0
a.fun(2) // 0
a.fun(3) // 0
// a.fun(1) a.fun(2) a.fun(3) 没有产生新的闭包对象（没有新的引用指向闭包对象），一直用的是var=fun(0)产生的闭包对象，闭包内的变量是n，n是第一次传入的0

var b = fun(0).fun(1).fun(2).fun(3) // undefined 0 1 2
// 每一次都返回新的对象，不断产生新的闭包对象，每一次都打印前一次传入的值（这个值是闭包对象里的值）

var c = fun(0).fun(1) // undefined 0
c.fun(2) // 1
c.fun(3) // 1
// 先生成c的闭包对象（打印undefined和0），之后一直用c里面的闭包对象，里面存着上一次的传入值1
```
