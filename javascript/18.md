# 内存泄漏

内存泄漏是指程序中分配的内存没有被释放，导致系统无法再次使用这些内存。

## 内存泄漏的场景

在 JavaScript 中，特别是在前端开发中，由于垃圾回收机制的存在，内存泄漏的情况相对较少，但仍然可能出现。以下是一些可能导致内存泄漏的场景：

1. **未及时清除定时器或事件监听器：** 在使用 `setInterval`、`setTimeout` 或 `addEventListener` 等定时器和事件监听器时，如果忘记在组件销毁时清除它们，就可能导致内存泄漏。

    ```javascript
    // 内存泄漏示例
    class MyClass {
      constructor() {
        this.intervalId = setInterval(() => {
          // some code
        }, 1000);
      }

      // 忘记在组件销毁时清除定时器
    }
    ```

2. **未解绑引用：** 在一些场景中，对象之间建立了引用，但未及时解绑这些引用，可能导致对象无法被垃圾回收。

    ```javascript
    // 内存泄漏示例
    let obj1 = {};
    let obj2 = {};

    obj1.reference = obj2;
    obj2.reference = obj1;

    // 这两个对象形成了循环引用，垃圾回收器无法回收它们
    ```

3. **闭包引用：** 当函数形成闭包时，如果闭包中引用了一些外部的变量，而这个闭包未及时被销毁，就可能导致引用的外部变量无法被回收。

    ```javascript
    // 内存泄漏示例
    function createClosure() {
      const data = "Some data";

      return function() {
        console.log(data);
      };
    }

    const leakyClosure = createClosure();

    // leakyClosure 一直存在，导致 data 无法被垃圾回收
    ```

4. **大量缓存数据：** 在某些场景中，如果持续缓存大量数据而不进行清理，可能导致内存泄漏。

    ```javascript
    // 内存泄漏示例
    class Cache {
      constructor() {
        this.data = [];
      }

      addData(item) {
        this.data.push(item);
      }
    }

    const myCache = new Cache();
    myCache.addData({ /* some data */ });

    // myCache 没有提供清理数据的方法，导致数据一直存在
    ```

5. **全局变量过多** 通常是变量未被定义或者胡乱引用了全局变量。

```js
// main.js
// 场景1
function a(){
    b=10;
}
a();
b++;

// 场景2
setTimeout(()=>{
    console.log(b)
},1000)
```

## 内存泄漏的时机

- 根据JS的垃圾回收机制，当内存中引用的次数为0的时候内存才会被回收
- 全局执行上下文中的对象被标记为不再使用才会被释放

TODO
